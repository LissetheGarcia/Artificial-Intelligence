# -*- coding: utf-8 -*-

import sqlite3
import pandas as pd

timeframes = ['2015-05']

for timeframe in timeframes:
    connection = sqlite3.connect('{}.db'.format(timeframe)) # Establece la conexion.
    c = connection.cursor() # Defines cursor 
    limit = 5000 # Size of portion that will be extracted from DB 
    last_unix = 0 # For extracting data from DB
    cur_length = limit # This will call when we have finished 
    counter = 0 # To display debugging information
    test_done = False # To say when we have finished to build test DB

    while cur_length == limit: 

        df = pd.read_sql("SELECT * FROM parent_reply WHERE unix > {} and parent NOT NULL and score > 0 ORDER BY unix ASC LIMIT {}".format(last_unix,limit),connection)
        last_unix = df.tail(1)['unix'].values[0] # Store last_unix to know which data to access after
        cur_length = len(df) #

        if not test_done:
            with open('test.from','a', encoding='utf8') as f:
                for content in df['parent'].values:
                    f.write(content+'\n')

            with open('test.to','a', encoding='utf8') as f:
                for content in df['comment'].values:
                    f.write(str(content)+'\n')

            test_done = True

        else:
            with open('train.from','a', encoding='utf8') as f: # utf-8 codifications
                for content in df['parent'].values: # For every row with a strong correlation threshold with a comment or answer
                    f.write(content+'\n') # writes in the file

            with open('train.to','a', encoding='utf8') as f: # Opens and closes the test DB file
                for content in df['comment'].values:
                    f.write(str(content)+'\n') # Writes in the field 

        counter += 1 # Increments counter that showed debugging information
        if counter % 20 == 0: # Output is showed every 20 iterations
            print(counter*limit,'So far completed lines')
